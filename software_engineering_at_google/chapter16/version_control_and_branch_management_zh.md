**第四部分**
**工具**

**第十六章**

***作者：提图斯·温特斯***

***编辑：Lisa Carey***

> 也许没有一种软件工程工具像版本控制那样被整个行业广泛采用。很难想象有哪个软件组织比少数人更大，不依赖正式的版本控制系统（VCS）来管理其源代码和协调工程师之间的活动。
>
> 在这一章中，我们将了解为什么版本控制的使用已经成为软件工程中一个明确的规范，我们将描述各种可能的版本控制和分支管理方法，包括我们如何在整个Google范围内进行扩展。我们还将检查各种方法的优缺点；尽管我们相信每个人都应该使用版本控制，但某些版本控制策略和流程可能比其他策略和流程更适合您的组织（或一般情况下）。特别是，我们发现DevOps推广的"基于主干的开发"（一个存储库，没有开发分支）是一种特别可伸缩的策略方法，我们将提供一些建议来解释为什么会这样。^1^
>
> **什么是版本控制？**
>
> ![](media/image2.gif){width="1.2604166666666667in" height="1.03125in"}这一部分对许多读者来说可能有点基础：毕竟，版本控制的使用是相当普遍的。如果你想跳到前面，我们建议跳到334页的"真相来源"一节。
>
> 1 DevOps研究协会在本章初稿和出版之间被谷歌收购，并在年度"DevOps报告"和《加速》一书中对此进行了广泛的发布。
>
> 据我们所知，它推广了基于主干的开发。
>
> VCS是一种跟踪文件随时间变化的修订（版本）的系统。VCS维护一些关于所管理的文件集的元数据，文件和元数据的副本统称为存储库（repo）。VCS允许多个开发人员同时处理同一组文件，从而帮助协调团队的活动。早期的VCS是这样做的：一次授予一个人编辑一个文件的权利，这种锁定方式足以建立序列（一种商定的"哪个更新"，VCS的一个重要特性）。更高级的系统确保对一次提交的文件集合的更改被视为单个单元（当逻辑更改涉及多个文件时，原子性）。像CVS（90年代流行的风投）这样没有原子性的提交系统会受到损坏和更改丢失的影响。确保原子性消除了以前的更改被无意覆盖的可能性，但需要跟踪在提交时最后一次同步到哪个版本，如果自本地开发人员上次同步以来提交中的任何文件在头部被修改，则提交将被拒绝。特别是在这样的变更跟踪VCS中，开发人员的托管文件的工作副本将因此需要自己的元数据。根据VCS的设计，存储库的这个副本可以是存储库本身，也可以包含少量的元数据，这样一个减少的副本通常是"客户机"或"工作区"^[\[1\]]{.ul}^
>
> 这看起来很复杂：为什么风投是必要的？是什么让这种工具成为为数不多的几乎通用的软件开发和软件工程工具之一？
>
> 想象一下在没有风投的情况下工作。对于一小部分（非常）分布式开发人员来说，他们在处理一个范围有限的项目时对版本控制没有任何了解，最简单和最低的基础设施解决方案就是来回传递项目的副本。当编辑是非同步的（人们在不同的时区工作，或者至少在不同的工作时间工作）时，这种方法最有效。如果有任何机会，人们不知道哪个版本是最新的，我们立即有一个恼人的问题：跟踪哪个版本是最新的。任何试图在非网络环境中协作的人都可能会想起来回复制名为Presentation v5-final-redlines-Josh&apos;s version v2的文件的恐怖。正如我们将看到的，当没有一个一致同意的真理来源时，合作就会变得非常摩擦和容易出错。
>
> 引入共享存储需要稍多的基础架构（访问共享存储），但提供了一个简单而明显的解决方案。在共享驱动器中协调工作可能只需要一小部分人，但仍然需要带外协作，以避免覆盖彼此的工作。此外，直接在共享存储中工作意味着任何不能使构建持续工作的开发任务都将开始妨碍团队中的每个人如果我在启动构建的同时对系统的某个部分进行更改，那么您的构建将无法工作。很明显，这不能很好地扩展。
>
> 实际上，缺少文件锁定和合并跟踪将不可避免地导致冲突和工作被覆盖。这样的系统很可能引入带外协调来决定谁在处理任何给定的文件。如果文件锁定是在软件中编码的，我们已经开始重新发明早期版本控制，比如RCS（以及其他）。当您意识到一次授予一个文件的写权限过于粗粒度，并且您开始想要行级跟踪时，我们肯定是在重新设计版本控制。我们几乎不可避免地需要一些结构化的机制来管理这些合作。因为我们似乎只是在这个假设中重新发明轮子，我们不妨使用现成的工具。
>
> **为什么版本控制很重要？**
>
> 虽然版本控制现在几乎无处不在，但情况并非总是如此。最早的VCSs可以追溯到20世纪70年代（SCCS）和80年代（RCS），比第一次提到软件工程作为一门独特的学科要晚很多年。在业界还没有正式的版本控制概念之前，团队就参与了"多人开发多版本软件"。版本控制是为了应对数字协作的新挑战而发展起来的。经过几十年的发展和传播，版本控制的可靠、一致的使用才发展成为今天的规范。那么，它是如何变得如此重要的呢？既然这似乎是一个不言而喻的解决方案，为什么会有人抵制风投的想法呢？^[\[2\]]{.ul}^
>
> 回想一下，软件工程是随着时间的推移而集成的编程；我们在源代码的即时生成和随着时间的推移保持该产品的行为之间画了一个区分（在维度上）。这种基本的区别在很大程度上解释了风投的重要性和对风投的犹豫：在最基本的层面上，版本控制是工程师管理原始源和时间之间相互作用的主要工具。我们可以将VCS概念化为一种扩展标准文件系统的方法。文件系统是从文件名到内容的映射。VCS扩展了它，提供了从（文件名、时间）到内容的映射，以及跟踪最后一个同步点和审核历史所需的元数据。版本控制使时间成为操作的一个明确的部分：在编程任务中是不必要的，在软件工程任务中是关键的。在大多数情况下，VCS还允许对该映射进行额外的输入（分支名称），以允许并行映射；因此：
>
> VCS（文件名、时间、分支）=\>文件内容
>
> 在默认用法中，分支输入将有一个通常理解的默认值：我们称之为"head"、"default"或"trunk"来表示主分支。
>
> 对于一致使用版本控制的（轻微的）犹豫不决几乎直接来自于编程和软件工程的融合我们教编程，我们训练程序员，我们面试基于编程问题和技术的工作。对于一个新员工来说，即使是在Google这样的地方，对由多个人或几个星期以上编写的代码几乎没有或根本没有经验也是完全合理的。鉴于这种经验和对问题的理解，版本控制似乎是一个陌生的解决方案。版本控制解决了一个我们的新员工不一定经历过的问题：一个"撤销"，不是针对单个文件而是针对整个项目，增加了很多复杂性，有时带来了不明显的好处。
>
> 在一些软件团队中，当管理层将技术人员的工作视为"软件开发"（坐下来编写代码）而不是"软件工程"（生成代码，使其在较长时间内保持工作状态并有用）时，同样的结果也会出现。以编程为主要任务的思维模式，以及对代码和时间流逝之间的相互作用的不太了解，很容易将"返回到以前的版本以撤消错误"描述为一种奇怪的、高开销的奢侈。
>
> 除了允许随着时间的推移单独存储和引用版本外，版本控制还帮助我们弥合单个开发人员和多开发人员进程之间的差距。实际上，这就是版本控制对软件工程如此重要的原因，因为它允许我们扩展团队和组织，尽管我们很少使用它作为"撤消"按钮。开发本质上是一个分支和合并的过程，无论是在多个开发人员之间还是在不同的时间点协调单个开发人员。VCS消除了"哪一个是最近的？"这个问题，现代版本控制的使用自动化了容易出错的操作，比如跟踪应用了哪一组更改。版本控制是我们协调多个开发人员和/或多个时间点的方式。
>
> 因为风投已经完全融入到软件工程的过程中，甚至连法律和监管实践都赶上了。VCS允许对每一行代码的每一次更改进行正式记录，这对于满足审计要求越来越必要。当混合使用内部开发和适当使用第三方源代码时，VCS可以帮助跟踪每一行代码的出处和起源。
>
> 除了跟踪源代码和处理同步/分支/合并操作的技术和法规方面之外，版本控制还会触发一些非技术性的行为变化。提交到版本控制并生成提交日志的过程是一个引发思考的时刻：自上次提交以来，您完成了什么？源头的状态是否令你满意？对于许多人来说，与承诺、写总结和完成任务相关的反省时刻本身就有价值。提交过程的开始是运行检查表、运行静态分析（参见第20章）、检查测试覆盖率、运行测试和动态分析等的最佳时机。
>
> 与任何进程一样，版本控制也会带来一些开销：必须有人配置和管理您的版本控制系统，并且每个开发人员都必须使用它。但别搞错了：这些几乎总是相当便宜的。有趣的是，大多数经验丰富的软件工程师会本能地对任何持续超过一两天的项目使用版本控制，即使是对单个开发人员项目。这一结果的一致性表明，在价值（包括风险降低）与管理费用之间进行权衡肯定是相当容易的。但我们已经承诺要承认环境的重要性，并鼓励工程领导人自己思考。它总是值得考虑的替代品，即使在一些基本的东西，如版本控制。
>
> 事实上，很难想象任何一项任务可以被认为是现代软件工程，而不是立即采用风投。既然您了解了版本控制的价值和需求，那么您现在很可能会问您需要什么类型的版本控制。

## 集中式风险投资与分布式风险投资

> 在最简单的层次上，所有现代VCS都是等价的：只要您的系统具有原子化地提交对一批文件的更改的概念，其他一切都只是UI。您可以用另一个VCS和一堆简单的shell脚本构建任何现代VCS的通用语义（而不是工作流）。因此，争论哪些风投"更好"主要是用户体验的问题核心功能是相同的，不同之处在于用户体验、命名、边缘案例功能和性能。选择VCS就像选择一种文件系统格式：在一种足够现代的格式中进行选择时，差异是相当小的，到目前为止，更重要的问题是您在系统中填充的内容和使用它的方式。然而，VCSs中的主要体系结构差异可能会使配置、策略和扩展决策变得更容易或更困难，因此必须意识到巨大的体系结构差异，主要是集中还是分散的决策。

### 集中式风投

> 在集中式VCS实现中，模型是单个中央存储库（可能存储在组织的某个共享计算资源上）的一个。尽管开发人员可以在其本地工作站上签出并访问文件，但需要将与这些文件的版本控制状态交互的操作（添加文件、同步、更新现有文件等）传送到中央服务器。开发人员提交的任何代码都会提交到该中央存储库中。最初的VCS实现都是集中式VCS。
>
> 回溯到20世纪70年代和80年代初，我们发现最早的VCS（如RCS）专注于锁定和防止多个同时编辑。您可以复制存储库的内容，但如果要编辑文件，则可能需要获得VCS强制执行的锁，以确保只有您在进行编辑。完成编辑后，释放锁。如果任何给定的更改都很快，或者在任何给定的时间很少有一个人以上需要文件的锁，那么该模型工作得很好。像调整配置文件这样的小编辑工作正常，就像在一个小团队中工作一样，这个团队要么保持不连贯的工作时间，要么很少长时间地处理重叠的文件。这种简单化的锁在规模上有着固有的问题：它可以很好地为少数人工作，但如果这些锁中的任何一个被争用，就有可能与更大的群体分道扬镳。作为对这种规模问题的回应，在90年代和21世纪初流行的VCS在更高的水平上运行。这些更现代的集中式VCS避免了独占锁定，但会跟踪同步的更改，要求编辑基于提交中每个文件的最新版本。CVS包装并细化了RCS，主要是一次操作一批文件，并允许多个开发人员同时签出一个文件：只要您的基本版本包含存储库中的所有更改，就可以提交。Subversion通过为提交、版本跟踪提供真正的原子性，并为异常操作（重命名、使用符号链接等）提供更好的跟踪，进一步提高了性能。集中式存储库/签出客户机模式在Subversion和大多数商业VCS中继续存在。^[\[3\]]{.ul}^

### 分布式VCS

> 从2000年代中期开始，许多流行的VCS都采用了分布式版本
>
> 控制系统（DVCS）范式，见于Git和Mercurial等系统。DVCS和更传统的集中式VCS（Subversion，CVS）在概念上的主要区别是："在哪里可以提交？"或者"这些文件的哪些副本可以算作存储库？"
>
> DVCS世界并不强制执行中央存储库的约束：如果您有存储库的副本（克隆、fork），那么您就有一个可以提交的存储库以及查询有关修订历史等信息所需的所有元数据。标准的工作流是克隆一些现有的存储库，进行一些编辑，在本地提交，然后将一些提交集推送到另一个存储库，该存储库可能是克隆的原始源，也可能不是克隆的原始源。任何中心性的概念都是纯粹的概念性的，是一个政策问题，而不是技术或基础协议的基础。
>
> DVCS模型允许更好的离线操作和协作，而不必内在地声明一个特定的存储库是真相的来源。一个存储库不必"提前"或"推迟"，因为更改不会固有地投射到线性时间线中。然而，考虑到通用性，集中式和DVCS模型在很大程度上是可互换的：集中式VCS通过技术提供了一个明确定义的中央存储库，而大多数DVCS生态系统将项目的中央存储库定义为策略问题。也就是说，大多数DVCS项目都是围绕一个概念性的事实来源（例如GitHub上的特定存储库）构建的。DVCS模型倾向于假设一个更分布式的用例，并且在开源世界中得到了特别强烈的采用。
>
> 一般来说，当今主流的源代码控制系统是Git，它实现了DVCS。当你有疑问的时候，用这个词，做别人做的事情是有价值的。如果您的用例预期是不寻常的，那么收集一些数据并评估权衡。^[\[4\]]{.ul}^
>
> Google与DVCS有着复杂的关系：我们的主存储库是基于一个（大规模）定制的内部集中式风投。我们定期尝试集成更多标准的外部选项，并与我们的工程师（尤其是Noogler）期望从外部开发中获得的工作流程相匹配。不幸的是，那些向Git这样更通用的工具发展的尝试被代码库和用户库的巨大规模所阻碍，更不用说Hyrum定律的影响了，它将我们与特定的风投和风投的接口联系在一起。这也许并不奇怪：大多数现有的工具不能很好地扩展到50000名工程师和数千万个提交。DVCS模型通常（但并非总是）包含历史和元数据的传输，需要大量数据来启动存储库。^[\[5\]]{.ul}^
>
> 在我们的工作流程中，代码库的中心性和云存储似乎对扩展至关重要。DVCS模型是围绕着下载整个代码库并在本地访问它的思想构建的。实际上，随着时间的推移以及组织规模的扩大，任何给定的开发人员都将在存储库中相对较少的文件百分比上操作，而这些文件的版本只占一小部分。随着我们的增长（文件数和工程师数），这种传输几乎完全变成了浪费。大多数文件在构建时都只需要局部性，但是分布式（和可复制的）构建系统似乎也能更好地扩展该任务（参见第18章）。

## 真理之源

> 集中式VCSs（Subversion、CVS、Perforce等）将真理之源的概念融入到系统的设计中：trunk最近提交的就是当前版本。当开发人员要签出项目时，默认情况下，主干版本就是他们将看到的版本。当在该版本的基础上重新提交更改时，您的更改即"完成"。
>
> 然而，与集中式VCS不同的是，在DVCS系统中，没有一个固有的概念，即分布式存储库的哪个副本是唯一的真实来源。从理论上讲，在没有集中或协调的情况下传递提交标签和pr是可能的，这使得不同的开发分支不受约束地传播，从而冒着概念性回归到Presentation v5-final-redlines-Josh版本v2的风险。正因为如此，DVCS需要比集中式风投更明确的政策和规范。
>
> 使用dvc的管理良好的项目将一个特定存储库中的一个特定分支声明为真相的来源，从而避免了更混乱的可能性。随着托管DVCS解决方案（如GitHub或GitLab）的普及，我们在实践中看到了这一点------用户可以为项目克隆和分叉存储库，但仍然有一个单一的主存储库：当他们在该存储库的主干分支中时，事情就"完成"了。
>
> 即使在数字视频监控系统的世界里，集权和真相的来源已经悄悄地回到使用中，这也不是偶然的。为了帮助说明这个真理来源的想法是多么重要，让我们想象一下当我们没有一个明确的真理来源时会发生什么。
